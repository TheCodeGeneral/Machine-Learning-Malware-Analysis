import os, threading, subprocess, re
from os import scandir, system, remove
from os.path import isfile, join


# Get the opcodes for all files in a directory
def dumpOpCodes(listOfFiles, writePath): 
    # Loop through each file in listOfFiles
    for f, file_path in listOfFiles:
        try:
            writedir = writePath
            # Get the file format

            fileFormat = subprocess.run(["objdump", "-f", file_path], capture_output=True)

            try:
                # Filter out only the architecture type
                fileFormat = re.search("file format (.+)", fileFormat.stdout.decode("utf-8")).group(1).strip()
            except:
                # objdump returns "file format not recognized"
                continue

            # TODO: Hash file to account for different versions

            # Write to directory depending on platform
            if "elf" in fileFormat:
                writedir = os.path.join(writedir, 'Linux', f + '_' + fileFormat + '.txt')
            elif "pe" in fileFormat:
                writedir = os.path.join(writedir, 'Windows', f + '_' + fileFormat + '.txt')
            else:
                continue

            # Skip dumping hex if file already exists
            if os.path.exists(writedir):
                continue
            
            # Dissasemble all headers in file without outputting addresses
            opCodes = subprocess.run(["objdump", "-M", "intel", "-b", fileFormat, "-s",  "-d", file_path], capture_output=True).stdout.decode("utf-8")

            # Filter out only hex using regex
            hexOnly = re.findall("\t(\w{2}( \w{2})*).+\t", opCodes)
            opCodes = ''
            for op in hexOnly:
                opCodes += ''.join(op) + '\n'
            
            # Find longest length instruction
            lines = opCodes.splitlines()
            maxLen = len(max(lines, key=len))
            
            # Pad each instruction to have same length
            opCodes = ''   
            for line in lines:
                while len(line) < maxLen:
                    line =  line  + ' 00'
                opCodes += line + '\n'

            # Write opCodes to file   
            with open(writedir, "w") as out:
                out.write(opCodes)
                #os.remove(file_path)
        except Exception as e:
            print(e)
            print(file_path)


def getSubDirectories(path):
    # Scan current directory for all other directories
    subdirectories= [f.path for f in scandir(path) if f.is_dir()]
    
    # For each directory recusively scan each directory
    for path in list(subdirectories):
        try:
            subdirectories.extend(getSubDirectories(path))
        except Exception as e:
            #print(e)
            pass
    return subdirectories

   
def getFilesInDirectory(path):
    files = []
    try:
        files = [(f.name, f.path) for f in scandir(path) if f.is_file()]
    except Exception as e:
        pass
        #print(e)

    return files
        
  
def getAllFiles(path):
    files = getFilesInDirectory(path)
    directories = getSubDirectories(path)
    for directory in directories:
        try:
            files.extend(getFilesInDirectory(directory))
        except Exception as e:
            #print(e)
            pass
    return files

def getPath():
    mypath = input("Enter directory to scan: ")
    while not os.path.exists(mypath):
        input("Directory does not exist\nEnter a valid directory: ")

    writedir = input("Enter write directory: ")
    
    # Make main directory if it doesn't exist
    while not os.path.exists(writedir):
        if input("Directory does not exist\nDo you want to create it? (y/n): ").lower() == 'n':
            writedir = input("Enter write directory: ")
        else:
            os.makedirs(writedir)
        
    # Make sub write directories if they don't exist
    test = os.path.exists(os.path.join(writedir,  'Windows'))
    if not test:
        os.makedirs(os.path.join(writedir,  'Windows'))

    if not os.path.exists(os.path.join(writedir, 'Linux')):
        os.makedirs(os.path.join(writedir, 'Linux'))
    
    return mypath, writedir


if __name__ == "__main__":
    mypath, writedir = getPath()
    
    if input("Do you want to scan each subdirectory? (y/n): ").lower() == 'n':
        files = getFilesInDirectory(mypath)
    else:
        files = getAllFiles(mypath)

    print(f"Scan Complete {len(files)} files")
    
    # Split list of files into smaller chunks
    numThreads = len(files) if len(files) < 64 else 64
    k,m = divmod (len(files), numThreads)
    listOfChunks = (files[i*k + min(1, m) : (i+1)*k + min(i+1, m)] for i in range(numThreads))
    listOfThreads = []
    

    # Start dissasembly threads
    print(f"Dumping op codes for files in {mypath}")
 
    for chunk in listOfChunks:
        listOfThreads.append(threading.Thread(target=dumpOpCodes, args=(chunk, writedir)))
        listOfThreads[-1].start()

    for thread in listOfThreads:
        thread.join()
        
    print("Finished")

