import os, threading, subprocess, re
from os import listdir, system, remove
from os.path import isfile, join


# Get the opcodes for all files in a directory
def dumpOpCodes(listOfFiles, mypath, writedir): 
    # Loop through each file in listOfFiles
    for f in listOfFiles:
        file_path = os.path.join(mypath, f)
        # Get the file format
        try:
            fileFormat = subprocess.run(["objdump", "-f", file_path], capture_output=True)

            # Check if file is made for a known architecture
            if "file format not recognized" in str(fileFormat):
                #os.remove(file_path)
                pass
            else:
                # Filter out only the architecture type
                fileFormat = re.search("file format (.+)", fileFormat.stdout.decode("utf-8")).group(1).strip()
                # Dissasemble all headers in file without outputting addresses
                opCodes = subprocess.run(["objdump", "-M", "intel", "-b", fileFormat, "-s",  "-d", file_path], capture_output=True).stdout.decode("utf-8")

                # Filter out only hex using regex
                hexOnly = re.findall("\t(\w{2}( \w{2})*).+\t", opCodes)
                opCodes = ''
                for op in hexOnly:
                    opCodes += ''.join(op) + '\n'
                
                # Find longest length instruction
                lines = opCodes.splitlines()
                maxLen = len(max(lines, key=len))
                
                # Pad each instruction to have same length
                opCodes = ''   
                for line in lines:
                    while len(line) < maxLen:
                        line =  line  + ' 00'
                    opCodes += line + '\n'

                # Write to directory depending on platform
                if "elf" in fileFormat:
                    writedir = os.path.join(writedir, 'Linux', f + '.txt')
                elif "pe" in fileFormat:
                    writedir = os.path.join(writedir, 'Windows', f + '.txt')
                else
                    continue
                    
                with open(writedir, "w") as out:
                    out.write(opCodes)
                    #os.remove(file_path)

        except:
            pass

if __name__ == "__main__":
    mypath = input("Enter directory: ")
    writedir = input("Enter write directory: ")
    
    # Make main directory if it doesn't exist
    if not os.path.exists(writedir):
        os.makedirs(writedir)
        
    # Make sub write directories if they don't exist
    if not os.path.exists(os.path.join(writedir,  'Windows')):
        os.makedirs(writedir + 'Windows')

    if not os.path.exists(os.path.join(writedir, 'Linux')):
        os.makedirs(os.path.join(writedir, 'Linux'))

    
    print("Scanning directory")
    # Filter out sub-directories 
    onlyFiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]
    print(f"Scan Complete {len(onlyFiles)} files")
    
    # Split list of files into smaller chunks
    numThreads = len(onlyFiles) if len(onlyFiles) < 32 else 32
    k,m = divmod (len(onlyFiles), numThreads)
    listOfChunks = (onlyFiles[i*k + min(1, m) : (i+1)*k + min(i+1, m)] for i in range(numThreads))
    listOfThreads = []
    

    # Start dissasembly threads
    print(f"Dumping op codes for files in {mypath}")
 
    for chunk in listOfChunks:
        listOfThreads.append(threading.Thread(target=dumpOpCodes, args=(chunk, mypath, writedir)))
        listOfThreads[-1].start()

    for thread in listOfThreads:
        thread.join()
        
    print("Finished")

