import os, threading, subprocess, re
from os import listdir, system, remove
from os.path import isfile, join
from queue import Queue

mypath = ''

def writeToFile(queue):
    # Open files to write to
    with open('opCodesWindows.txt', 'a') as fileWindows:
        with open('opCodesLinux.txt', 'a') as fileLinux:
            with open('opCodesUnknownArchitecture.txt', 'a') as fileUnknown:
                
                # Continue to get next item to write to files
                while True:
                    nextToWrite = queue.get()
                    if nextToWrite[0] == "Linux":
                        fileLinux.write(nextToWrite[1])
                        fileLinux.flush()
                    elif nextToWrite[0] == "Windows":
                        fileWindows.write(nextToWrite[1])
                        fileWindows.flush()
                    else:
                        fileUnknown.write(nextToWrite[1])
                        fileUnknown.flush()
                    
                    # Remove item from the queue
                    queue.task_done()

                    
# Get the opcodes for all files in a directory
def dumpOpCodes(listOfFiles, threadNum, queue): 
    # Loop through each file in listOfFiles
    for f in listOfFiles:
        file_path = mypath + f
        
        # Get the file format
        fileFormat = subprocess.run(["objdump", "-f", file_path], capture_output=True)

        # Check if file is made for a known architecture
        if "file format not recognized" in str(fileFormat):
            print(f"Thread {threadNum}:\tUnrecognized format\nRemoving {f}", flush=True)
            os.remove(file_path)
        else:
            # Filter out only the architecture type
            fileFormat = re.search("file format (.+)", fileFormat.stdout.decode("utf-8")).group(1).strip()
            # Dissasemble all headers in file without outputting addresses
            opCodes = subprocess.run(["objdump", "-M", "intel", "-b", fileFormat, "-S", "--no-addresses",  "-D", file_path], capture_output=True).stdout.decode("utf-8")
            
            # Add opcodes to queue to be written
            if "elf" in fileFormat:
                queue.put(('Linux', opCodes))
            elif "pe" in fileFormat:
                queue.put(('Windows', opCodes))
            else:
                queue.put(('Unknown', opCodes))

if __name__ == "__main__":
    mypath = input("Enter directory: ")
    queue = Queue()
    
    if mypath[-1] != '\\':
        mypath += '\\'
    
    print("Scanning directory")
    # Filter out sub-directories 
    onlyFiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]
    print(f"Scan Complete {len(onlyFiles)} files")
    
    # Split list of files into smaller chunks
    numThreads = len(onlyFiles) if len(onlyFiles) < 128 else 128
    k,m = divmod (len(onlyFiles), numThreads)
    listOfChunks = (onlyFiles[i*k + min(1, m) : (i+1)*k + min(i+1, m)] for i in range(numThreads))
    listOfThreads = []
    
    # Start writer thread using queues
    writerThread = threading.Thread(target=writeToFile, args=(queue,), daemon=True)
    writerThread.start()

    # Start dissasembly threads
    print(f"Dumping op codes for files in {mypath}")
    threadNum = 1   
    for chunk in listOfChunks:
        listOfThreads.append(threading.Thread(target=dumpOpCodes, args=(chunk, threadNum, queue)))
        listOfThreads[-1].start()
        threadNum+=1
    for thread in listOfThreads:
        thread.join()
    
    # Wait for all disassembled files to finish writing
    queue.join()
        
    print("Finished")
